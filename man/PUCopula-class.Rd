% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PUcopula.R
\docType{class}
\name{PUCopula-class}
\alias{PUCopula-class}
\alias{PUCopula}
\alias{initialize,PUCopula-method}
\title{An S4 class to represent a partition of unity copula.}
\usage{
\S4method{initialize}{PUCopula}(.Object, dimension = 0, factor = 1,
  family = c("binom", "nbinom", "poisson", "sample", "gamma", "beta"),
  pars.a = c(10, 10), patch = c("rook", "uFrechet", "lFrechet",
  "varwc", "Gauss"), data, continuous = logical(0), numericCDF = FALSE)
}
\value{
An object of class PUcopula
}
\description{
An S4 class to represent a partition of unity copula.
}
\section{Methods (by generic)}{
\itemize{
\item \code{initialize}: initializes a PUcopula object
}}

\section{Slots}{

\describe{
\item{\code{dim}}{A length-one numeric vector; dimension of PU-copula}

\item{\code{family}}{Character or vector of characters: family determining the desnities fdens}

\item{\code{par.factor}}{A length-n numeric vector}

\item{\code{pars.a}}{A length-one numeric vector: defined as integral from 0 to 1 over phi(s,u) for s in r. Will be evauated numerically}

\item{\code{p}}{A length-one numeric vector}

\item{\code{phis}}{A list of functions \eqn{\varphi_k(s,u)}{phi_k(s,u)} for \eqn{k=1,dots,d\in N}{k=1,...,d in N}.    Either continuous case: A list of functions which represent Lebesgue densities of distributions over R with a parameter u in (0,1), i.e.
\deqn{\varphi_k(s,u)\geq 0 \text{ and } \int_{-\infty}^\infty \varphi_k(s,u)\, ds = 1 \text{ for } u \in (0,1),}{phi_k(s,u) \geq 0 and \int phi_k(s,u), ds = 1 for u in (0,1),}
Or (discrete case): A list of functions which represent discrete probabilities over Z+ with a parameter u in (0,1).}

\item{\code{alphs}}{A list of functions. Integral over the elements of phis w.r.t. u, i.e. \deqn{\alpha_k(s):=\int_0^1 \varphi_k(s,u)\, du \in (0,\infty)}{alpha_k(s):=int_0^1 phi_k(s,u) du in (0,\infty)}}

\item{\code{alphsCDF}}{A list of functions. CDFs corresponding to the densities defined by alphs, i.e. \deqn{A_k(s) := \int_{-\infty}^s \alpha_k(w) \, dw \text{ for } s \in R}{A_k(s) := int_-\infty^s alpha_k(w) dw for s in R}}

\item{\code{fdenss}}{A list of functions. Densities obtained from normalizing the functions \eqn{\varphi(s,u)}{phi(s,u)} (from slot phis) w.r.t. \eqn{u \in 0,1}{u in (0,1)}, i.e. \deqn{f_k(s,u) := \frac{\varphi_k(s,u)}{\alpha_k(s)}, \, u \in (0,1) \text{ for } s \in R}{f_k(s,u) := phi_k(s,u)/alpha_k(s), u in (0,1) for s in R}}

\item{\code{PUdens}}{density function of the (continuous) partition of unity copula defined by  \deqn{c(\mathbf{u}) := \int_{-\infty}^\infty \cdots \int_{-\infty}^\infty p(s_1,\cdots,s_d) \prod_{k=1}^d f_k(s_k, u_k) \, ds_1 \cdots ds_d, \mathbf{u} = (u_1,\cdots,u_d) \in (0,1)^d }{c(u) := int ... int p(s_1,...,s_d) \prod_k=1^d f_k(s_k, u_k) ds_1 ... ds_d, u = (u_1,...,u_d) in (0,1)^d }
where \eqn{p(s_1,\cdots,s_d)}{p(s_1,...,s_d)} denotes the density of an arbitrary \eqn{d}-dimensional random vector \eqn{\mathbf{S}=S_1,\cdots,S_d)}{S=S_1,...,S_d)} over \eqn{R^d} with marginal densities \eqn{\alpha(cdot)}{alpha_k(.)} for \eqn{S_k}.}

\item{\code{fq}}{A length-one numeric vector}

\item{\code{gq}}{A length-one numeric vector}

\item{\code{patch}}{A length-one numeric vector}

\item{\code{data}}{A length-one numeric vector}

\item{\code{ranks}}{A length-one numeric vector}

\item{\code{relRanks}}{A length-one numeric vector}

\item{\code{rpatch}}{A function which generates random samples from the specified patchwork.}

\item{\code{patchpar}}{Parameter for the chosen patchwork type (used currently for type Gauss)}

\item{\code{rand}}{random number generator to simulate from PU copula}
}}

\examples{
# Use dataset stormflood
data(stormflood)

# example: choose Gamma copula model
x <- PUCopula(family="gamma", pars.a=c(40, 43), patch="lFrechet",data=stormflood)

# The following plots show the common ranks and several copula drivers;
#   these plots do not depend on the above chosen family of the PUcopula.
# 2*3 plots in one
par(mfrow=c(2,3))
# plot the empirical rank vectors
plot(x@ranks, sub="emp. rank vectors", xlab="", ylab="")
# plot the lower Fréchet driver, i.e. phi=-1
plot(x@rpatch(2000,"lFrechet"), sub="lower Fréchet driver, phi=-1", xlab="", ylab="")
# plot for phi=-0.8
plot(x@rpatch(2000,"Gauss",-0.8), sub="phi = -0.8", xlab="", ylab="")
# plot for phi=0 (rook copula)
plot(x@rpatch(2000,"rook"), sub="rook copula, phi=0", xlab="", ylab="")
# plot for phi=0.9
plot(x@rpatch(2000,"Gauss",0.9), sub="phi=0.9", xlab="", ylab="")
# plot for phi=1 (upper Fréchet driver)
plot(x@rpatch(2000,"uFrechet"), sub="upper Fréchet driver, phi=1", xlab="", ylab="")
# single plot window
par(mfrow=c(1,1))

# plot the densities given by phis (=densities of Gamma distributions)
# plot for s=1,3,5,7,...,999 (s must be in (0,inf))
palette(rainbow(10))
xs=c(seq(0,0.01,length.out=200),seq(0.02,1,length.out=200))
# function phi for a fixed s
foo <- function(u) x@phi(u,1)
ys=foo(xs)
# plot for s=1
plot(x=xs,y=ys, col=1, ylim=c(0,0.4), xlim=c(0,1),type = "l") #plot(foo, col=1, ylim=c(0,0.94), xlim=c(0,1)) # ylim=c(0,1e-88)
# repeat for  s=3,5,7,...,999
for (i in 2:500) {
  foo <- function(u) x@phi(u,i*2-1)
  ys=foo(xs)
    lines(x=xs,y=ys, col=i+1) #plot(foo, add=TRUE, col=i+1)
}
# for a Gamma PUC the alphs are densities of inverse Pareto distributions...
plot(x@alphs[[1]], xlim=c(0,500))
# the fdenss are basically a normalization of the phis using alphs - for a fixes s they are densities of exponentially transformed Gamma distributions
# heatplot:
us <- seq(0,1,length.out=100)
ss <- seq(1,500,length.out=100)
zs <- matrix(nrow=length(us),ncol=length(ss))
for (s in 1:length(ss)) zs[,s] <- x@fdenss[[1]](us, s)
image(x=us, y=ss, z=zs, col=terrain.colors(15))

#For the simulation from the Gamma copula, the slots alphsCDF and Qk/corresponnding quantile are used internally
# plot the CDF corresponding to density alphs[1]
plot(x@alphsCDF[[1]],xlim=c(0,100))
x@alphsobjective[[1]](5,0.8)
x@alphsquant[[1]](0.8)
x@rand(1)

# Create a beta copula
x <- PUCopula(family="beta", pars.a=c(40, 43), patch="lFrechet",data=stormflood)
x@phi(0.5,0.5)
#[1] 2.210851e-11
x@alph(0.6)
#[1] 1.458522e-11
#x@fdens(0.5,0.6)
#[1] 0.0002381545
#x@gdens(0.5,0.6)
#[1] 0.0001616076
x@fdenss[[1]](0.5,0.6)
#[1] 0.0002381545
x@fdenss[[2]](0.5,0.6)
#[1] 0.0001616076
x@rand(5)
#does not work
# example 2: gamma copula
x <- PUCopula(family="gamma", pars.a=c(40, 43), patch="lFrechet",data=stormflood)
#plot alpha(s)
plot(x@alphs[[1]])
#the numerically computed alpha is quite close:
s<-10
x@pars.a[1]*s^(x@pars.a[1]-1)/((1+s)^(x@pars.a[1]+1))
#[1] 0.008034519
x@alph(s)
#[1] 0.008034519
# but of course shows some inaccuracies:
s<-2.5
x@alph(s)
#[1] 6.530307e-06
x@pars.a[1]*s^(x@pars.a[1]-1)/((1+s)^(x@pars.a[1]+1))
#[1] 6.530261e-06
}
